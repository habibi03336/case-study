# 비밀번호와 주민등록번호 암호화

개인정보보호법 따라서 개인정보는 암호화하여 저장해야한다. 왜 암호화해서 저장해야할까? 여기에는 두 가지 정도의 이유가 있다고 생각한다.

1. 내부 임직원의 부정사용 방지

   보통 일반 개발자나 임직원이 개인정보가 담긴 데이터베이스에 접근하지 못하도록 관리를 한다. 하지만 심각한 장애가 발생한 상황같이 특수한 상황에서는 문제를 빠르게 해결하기 위해서 이러한 관리 규칙이 후순위로 밀릴 수 있다. 또한 데이터베이스 총 관리자와 같이 적어도 일부의 사람들은 접근 권한을 가지고 있을 수 밖에 없다. 따라서 민감한 데이터는 암호화를 통해 알아보기 쉽지 않게 변경하여 저장할 필요가 있다.

2. 데이터 탈취시 피해 최소화

   데이터 자체는 유출되었어도 충분한 암호화가 되어있다면 유의미한 데이터를 추출하기가 힘들다. 따라서 암호화를 통해서 데이터 탈취시에도 피해를 최소화 할 수 있다.

비밀번호와 주민등록번호를 암호화할 일이 생겨 그 방식을 좀 더 구체적으로 알아봤다.

# 비밀번호 암호화 By 단방향 암호화 (해시, Hash)

단방향 암호화는 A => B 로의 변환은 쉽지만, B => A 로의 변환은 쉽지 않은 해시함수를 활용하여 이루어진다. 즉 f(a) = b는 쉽게 계산되지만, 이에 대한 역함수는 존재하지 않는 함수를 활용한다. 이 떄문에 B를 알아내더라도 A가 무엇이었는지는 알기 힘든 특징을 가진다.

이는 `비밀번호`와 같은 개인정보를 저장할 떄 적용하는 암호화 방식이다. 비밀번호는 입력이 정확한지를 확인하는데에만 쓰이면 된다. 즉 실제 그 비밀번호 데이터가 무엇인지는 중요하지 않다. 오히려 사용자만 알고 있는 것이 더 안전하다.

데이터 베이스가 탈취되었을 때, 해시값으로 부터 실제 비밀번호를 알기내기 위해서 모든 입력값을 대입해보면서 동일한 해시값이 있는지를 확인하는 브루트 포스 공격이 이루어질 수 있다.

> 예를 들어, 8자리이고 영어 알파벳과 숫자로만 이루어진 비밀번호를 타겟팅해서 알아내려고 한다고 해보자. 그러면 62(a-zA-Z0-9)의 8제곱(약 200조)번 해시함수를 돌리면 모든 경우의 수에 대한 레인보우 테이블(입력값과 해시값을 매핑한 테이블)을 생성할 수 있다.
>
> 약 250만원 정도하는 NVDIA의 RTX 4090 그래픽 카드는 SHA2-256 해시를 초당 약 200억번 할 수 있다고 한다. 대략 166분만에 레인보우 테이블을 만들 수 있다. 즉 단순히 해시함수만 활용하여 암호화를 하는 경우 제 역할을 하지 못한다.
>
> [NVDIA RTX 4090 Benchmark](https://gist.github.com/Chick3nman/32e662a5bb63bc4f51b847bb422222fd)

## 솔팅 (salting)

솔팅이라는 방식을 적용하면 더 강력한 암호화를 할 수 있다. 해시를 하기 전에 각각의 비밀번호에 소금을 살짝 쳐주는 것이다.

예를 들어 비밀번호 'abcd1234'가 있으면 무작위로 생성한 솔트 'D;%yL9TS:5PalS/d'를 뒤나 앞쪽에 붙인 후 해시를 한다. 그리고 해시값과 솔트 'D;%yL9TS:5PalS/d'를 데이터베이스에 저장한다.

유저가 비밀번호로 인증을 하려고 할 때 '입력값 + 솔트'를 한 후 해시를 하고, 이 값과 데이터베이스의 해시값을 비교하여 인증을 해주게 된다.

이러한 방식을 적용하면 레인보우 테이블 만들기가 더 어려운 일이 된다. 무작위로 생성된 솔트가 붙어있기 때문에, salt specific한 레인보우 테이블을 만들어진다.

일반적으로 비밀번호 별로 모두 서로 다른 salt를 가지고 있을 것이기 때문에 (비밀번호 개수) x (레인보우 테이블 생성 비용)의 연산이 필요하게 된다. 즉 솔트가 없어다면 한 번의 레인보우 테이블 생성으로 모든 비밀번호를 알 수 있지만, 솔트 때문에 한 번의 레인보우 테이블로는 한 개의 비밀번호만 알아낼 수 있게 된다.

## 키 스트레칭 (key stretching)

해시 암호화를 더 강력하게 하기 위해서 키 스트레칭이라는 방식을 추가로 적용한다. 이는 한 번 해시된 값을 N번 더 해시하는 방식이다. 일반 사용자의 경우 N번더 해시를 한다고 해도 O(N)이기 때문에 비용이 크지 않다. 하지만 공격자의 경우 O(N \* 레인보우테이블생성비용)이 되기 때문에 지불해야 하는 비용이 매우 커진다. 솔팅과 키 스트레칭을 함께 사용하면 하나의 비밀번호를 알아내는데 O(N \* 레인보우테이블생성비용)이 드는 셈이다.

> 위 예시를 가져와 시간으로 따져보자. 만약 공격자가 거금 200억을 투자하여 NVDIA의 RTX 4090 그래픽 카드 8000개를 사용한다고 해보자. 그러면 N=1일 때 1.245초(166분 / 8000)에 비밀번호 1개를 알아낼 수 있다. 하지만 만약 N이 100,000이면 34.5시간 정도가 걸린다.

## 비밀번호 해시 알고리즘

### PDKDF

PDKDF는 ISO-27001 보안 규정을 준수하고 있는 국제 표준 해시 암호화 알고리즘이 있다. 일반적인 해시에 많이 쓰이는 SHA256, SHA512, HMAC SHA 해시 등 SHA-2 계열 해싱을 활용한다. SHA-2 계열의 해싱 알고리즘은 매우 빠른 해싱 속도를 가지고 있다. 다른 유즈케이스에서는 장점이겠지만 비밀번호에 있어서는 브루트 포스 공격을 용이하게 하므로 단점이다. 따라서 PDKDF는 솔팅을 적용하고, key stretching을 여러번 하도록 설계되었다.

### Bcrypt

Bcrypt는 내부적으로 속도가 느린 Blowfish 암호화 알고리즘을 사용하기 때문에 기본적인 해싱 속도가 SHA 계열 해시보다 훨씬 느리다. 그리고 솔팅, 키 스트레칭 또한 활용한다.

`PDKDF, Bcrypt 모두 해싱에 걸리는 시간을 일부로 지연시켜 브루트 포스 공격으로부터의 방어력을 높인다는 점에서 동일하다.` 두 방식 모두 믿고 쓸 수 있는 방식이고, 둘 다 성능을 원하는 대로 튜닝 할 수 있기 때문에 별 다른 요구사항이 없다면 원하는 것을, 원하는 보안수준에 맞춰 사용하면 된다.

> RTX 4090 벤치마크를 보면 SHA256을 적용한 PBKDF2에 키 스트레칭을 2만번 한 경우 해시레이트가 초당 43만번으로 속도가 급격하게 줄어든다. Bcrypt의 경우 초당 18만번 정도로 더 낮은 속도를 보여준다.
>
> [NVDIA RTX 4090 Benchmark](https://gist.github.com/Chick3nman/32e662a5bb63bc4f51b847bb422222fd)

---

ps. 사실 단방향 암호화는 영어로는 암호화(encryption)라고 하지 않는다. 해시(hash)라고 한다. 한국에서는 다소 혼용하여 사용하고 있는 것 같다.

# 주민번호 암호화 By 양방향 암호화 (인크립션, Encryption)

`주민등록번호`는 매우 민감한 개인정보이다. 하지만 서비스를 제공하면서 주민등록번호 직접 사용해야하는 경우가 있을 수 있다. 따라서 비밀번호 처럼 단방향 암호화를 해서는 안된다. 암호화와 복호화가 모두 가능한 양방향 암호화를 사용해야 한다.

양방향 암호화에는 크게 `대칭 암호화`와 `비대칭 암호화` 두 가지 종류가 있다. 대칭 암호화는 하나의 비밀 키로 암호화, 복호화 모두를 하는 방식을 의미한다. 비대칭 암호화는 A키로 암호화를 했으면 B키로 복호화가 되고, B키로 암호화를 하면 A키로 복호화가 되는 방식을 의미한다. 비대칭 암호화는 공개키-비공개키 방식으로 많이 쓰인다. 일반적으로 주민등록번호를 데이터베이스에 저장할 때는 대칭 암호화를 활용하면 될 것으로 보인다.

대칭 암호화의 대표적인 알고리즘으로 `AES` 암호화 알고리즘이 있다.

AES 암호화 알고리즘은 키 길이에 따라 AES-128, AES-192, AES-256이 있다. [키 길이가 길 수록 더 보안 성능이 높아지는 것은 맞으나 리소스를 많이 사용한다. AES-128도 충분한 보안 성능을 보여준다.](https://www.appsealing.com/aes-128-encryption/) 하지만 미래 컴퓨터 성능이 더 좋아질 것을 염두해서 192나 256을 쓰는 경우가 더 많은 것 같다.

## 권장과 요구사항의 충돌

[AES에는 대표적으로 ECB, CBC, CFB, OFB, CTR 모드가 있다.](https://www.highgo.ca/2019/08/08/the-difference-in-five-modes-in-the-aes-encryption-algorithm/)

주민등록번호의 경우 유일성(uniqueness) 조건이 있을 수 있고, 검색을 하는 경우도 있을 수 있기 때문에 결정적(deterministic)인 암호화 방식을 사용하는 하고자 했다. 이 요구사항을 충족하기 위해서는 ECB 모드가 적절해 보였다. ECB 모드를 제외하고 다른 모드는 암호화를 할 때 기본적으로 무작위성(randomness)를 추가하기 때문에 결정적인 성질을 가지고 있지 않았다.

[하지만 검색을 하다보니 `ECB 모드는 보안에 취약점이 있어서 사용하면 안된다`는 글들을 찾을 수 있었다.](https://crypto.stackexchange.com/questions/20941/why-shouldnt-i-use-ecb-encryption) ECB는 사용하지 않는게 일반적인 권장사항이었다.

이 권장사항을 따르지 않아도 되는지 판단하기 위해서 `ECB 모드의 취약점`과 `주민등록번호 암호화 요구사항이 가진 세부사항` 두 가지를 파악해야했다.

## ECB 모드가 취약한 이유

ECB모드가 다른 모드에 비해서 취약한 이유는 크게 2가지가 있었다.

### 메세지의 내부적인 패턴이 드러남

AES 기반 암호화는 메세지를 작은 블럭으로 쪼갠후 각 블럭을 암호화 하는 방식이다. ECB는 각 블럭에 동일한 암호화를 적용한다. 블럭 단위로 같은 값을 가진다면 어떤 패턴이 드러날 수 있다.

<div style="text-align: center;">
    <img src="https://raw.githubusercontent.com/habibi03336/case-study/master/2024-01-31-password-ssn-encryption/img/ecb-vulneralbility.png" alt="ecb vulneralbility" width="500"/>
</div>

이러한 문제를 해결하기 위해서 ECB 외의 모드는 앞 쪽 블럭의 암호화 결과를 반영해 뒤 쪽 블럭을 암호화 하는 등의 방식으로, 무작위성을 추가해 문제를 해결했다.

### 외부 정보와 결합해 메세지의 뉘앙스가 드러날 수 있음

ECB의 또 다른 단점은 결정적(deterministic)하다는 점이다. plain text와 key가 같으면 항상 같은 암호를 반환한다. 따라서 이 암호와 외부 정보가 어떤 패턴을 이루어 나타난다면, 암호를 풀지 않고도 암호가 어떤 뉘앙스를 가지는지 유추할 수 있다. ECB 모드를 제외하고 다른 모드는 기본적으로 결정적인 속성을 초기 무작위성으로 제거한다.

> 예를 들어 공격하라는 지시를 ECB 암호화를 해서 보낸다고 해보자. 만약 이 암호 신호 전달될 때마다 공격이 이루어지는 패턴이 몇 번 나타나다보면 적군은 이 암호가 정확이 무슨 의미인지는 몰라도, 공격과 관련된 내용임을 알 수 있다.

ECB가 가지는 두 가지 취약점이 결합하면 더 큰 취약점으로 드러난다.

> 예를 들어 주민번호 240131-3177622가 있을 때, 만약 "240131-3"과 "177622"로 쪼개져서 암호화가 된다면 태어난 날과 성별이 같은 사람은 암호 앞 쪽 값이 모두 동일할 것이다. 24년 1월 31일에 태어난 남자인 사람은 암호 앞 쪽 값이 모두 동일하다. 이 정보는 외부 정보와 결합됐을 때 충분히 어떤 뉘앙스를 전달할 수 있다.
>
> 블럭 단위로 패턴이 드러나는 것과 결정적인 속성이 만나 더 큰 취약점이 된다.

## 주민등록번호 암호화의 세부사항

plain text에 패턴이 있는 경우, 그리고 암호가 어떤 뉘앙스를 전달 할 수 있는 경우에 ECB 모드가 취약할 수 있다는 점을 알았다. 그러면 주민번호 암호화에서도 이런 취약점이 유의미할까?

그렇지 않다고 판단했다. 무엇보다 주민번호 암호화의 결과가 딱 1블럭이기 때문이다. AES 암호화는 1블럭의 크기가 16Byte, 128bit이다. 주민번호는 길이가 14byte로 짧아 딱 1블럭으로 암호화 된다. 따라서 암호에서 패턴이 있을 수 없다.

또한 주민등록번호는 사람마다 딱 1개 가지고 있는 특수한 값으로, 암호화의 결과가 모두 다르다. 암호화된 주민번호가 어떤 뉘앙스를 가지고 있지 않다.

따라서 주민번호에 AES-ECB 방식을 적용하여 안전하고 결정적인 특징을 가지는 암호화를 할 수 있다.

<!-- https://blog.humminglab.io/posts/tls-cryptography-4-block-cipher-mode/ -->
<!-- https://crypto.stackexchange.com/questions/81989/aes-ecb-vs-aes-cbc-for-16-bytes -->
